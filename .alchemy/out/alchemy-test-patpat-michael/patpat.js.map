{
  "version": 3,
  "sources": ["../../../utils/nanoid.ts", "../../../deployments/alchemy-worker/src/patpat.ts"],
  "sourceRoot": ".alchemy/out/alchemy-test-patpat-michael",
  "sourcesContent": ["//* nanoid became runtime specific in v5; breaking support for cloudflare workers\n//* this is the same version as v5 but written to work w/ webcrypto instead of node:crypto\nconst POOL_SIZE_MULTIPLIER = 128;\nlet pool: Uint8Array;\nlet poolOffset: number;\n\nfunction fillPool(bytes: number) {\n\tif (!pool || pool.length < bytes) {\n\t\tpool = new Uint8Array(bytes * POOL_SIZE_MULTIPLIER);\n\t\tcrypto.getRandomValues(pool);\n\t\tpoolOffset = 0;\n\t} else if (poolOffset + bytes > pool.length) {\n\t\tcrypto.getRandomValues(pool);\n\t\tpoolOffset = 0;\n\t}\n\tpoolOffset += bytes;\n}\n\nexport function idGenerator(alphabet: string, defaultSize: number) {\n\tconst mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1;\n\tconst step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length);\n\n\treturn (size = defaultSize) => {\n\t\tlet id = \"\";\n\t\twhile (true) {\n\t\t\tfillPool(step);\n\t\t\tconst bytes = pool.subarray(poolOffset - step, poolOffset);\n\t\t\tfor (let i = 0; i < step; i++) {\n\t\t\t\t// biome-ignore lint/style/noNonNullAssertion: we iterate down from step. will always exist\n\t\t\t\tid += alphabet[bytes[i]! & mask] || \"\";\n\t\t\t\tif (id.length === size) {\n\t\t\t\t\treturn id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\nexport const DEFAULT_ALPHABET =\n\t\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\nexport const DEFAULT_LENGTH = 10;\nexport const id = idGenerator(DEFAULT_ALPHABET, DEFAULT_LENGTH);\n\nexport const HEX_ALPHABET = \"0123456789abcdef\";\nexport const HEX_LENGTH = 16;\nexport const hexId = idGenerator(HEX_ALPHABET, HEX_LENGTH);\n", "import { id as nanoid } from \"../../../utils/nanoid\";\n\nexport default {\n\t// biome-ignore lint/suspicious/useAwait: its fine\n\tasync fetch(): Promise<Response> {\n\t\tconst id = nanoid();\n\t\tconst message = `Haiii - patpat! ${id}`;\n\t\tconsole.log(message);\n\t\treturn new Response(message);\n\t},\n};\n"],
  "mappings": ";;;;AAEA,IAAM,uBAAuB;AAC7B,IAAI;AACJ,IAAI;AAEJ,SAAS,SAAS,OAAe;AAChC,MAAI,CAAC,QAAQ,KAAK,SAAS,OAAO;AACjC,WAAO,IAAI,WAAW,QAAQ,oBAAoB;AAClD,WAAO,gBAAgB,IAAI;AAC3B,iBAAa;AAAA,EACd,WAAW,aAAa,QAAQ,KAAK,QAAQ;AAC5C,WAAO,gBAAgB,IAAI;AAC3B,iBAAa;AAAA,EACd;AACA,gBAAc;AACf;AAVS;AAYF,SAAS,YAAY,UAAkB,aAAqB;AAClE,QAAM,QAAQ,KAAM,KAAK,KAAK,MAAO,SAAS,SAAS,IAAK,CAAC,KAAM;AACnE,QAAM,OAAO,KAAK,KAAM,MAAM,OAAO,cAAe,SAAS,MAAM;AAEnE,SAAO,CAAC,OAAO,gBAAgB;AAC9B,QAAIA,MAAK;AACT,WAAO,MAAM;AACZ,eAAS,IAAI;AACb,YAAM,QAAQ,KAAK,SAAS,aAAa,MAAM,UAAU;AACzD,eAAS,IAAI,GAAG,IAAI,MAAM,KAAK;AAE9B,QAAAA,OAAM,SAAS,MAAM,CAAC,IAAK,IAAI,KAAK;AACpC,YAAIA,IAAG,WAAW,MAAM;AACvB,iBAAOA;AAAA,QACR;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAlBgB;AAoBT,IAAM,mBACZ;AACM,IAAM,iBAAiB;AACvB,IAAM,KAAK,YAAY,kBAAkB,cAAc;AAEvD,IAAM,eAAe;AACrB,IAAM,aAAa;AACnB,IAAM,QAAQ,YAAY,cAAc,UAAU;;;AC3CzD,IAAO,iBAAQ;AAAA;AAAA,EAEd,MAAM,QAA2B;AAChC,UAAMC,MAAK,GAAO;AAClB,UAAM,UAAU,mBAAmBA,GAAE;AACrC,YAAQ,IAAI,OAAO;AACnB,WAAO,IAAI,SAAS,OAAO;AAAA,EAC5B;AACD;",
  "names": ["id", "id"]
}
